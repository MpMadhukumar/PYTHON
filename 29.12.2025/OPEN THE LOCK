class Solution(object):
    def openLock(self, deadends, target):
        """
        :type deadends: List[str]
        :type target: str
        :rtype: int
        """
        start_combo = "0000"
        visited = set(deadends)
        if start_combo in visited:
            return -1
        next_digit = {
            "0": "1",
            "1": "2",
            "2": "3",
            "3": "4",
            "4": "5",
            "5": "6",
            "6": "7",
            "7": "8",
            "8": "9",
            "9": "0"
        }
        prev_digit = {
            "1": "0",
            "2": "1",
            "3": "2",
            "4": "3",
            "5": "4",
            "6": "5",
            "7": "6",
            "8": "7",
            "9": "8",
            "0": "9"
        }
        queue = deque([start_combo])
        visited.add(start_combo)
        turns_count = 0
        while queue:
            for _ in range(len(queue)):
                current_combo = queue.popleft()
                if current_combo == target:
                    return turns_count
                for i, digit in enumerate(current_combo):
                    new_combo_list = list(current_combo)
                    new_combo_list[i] = next_digit[digit]
                    new_combo_str = "".join(new_combo_list)
                    if new_combo_str not in visited:
                        visited.add(new_combo_str)
                        queue.append(new_combo_str)
                    new_combo_list[i] = prev_digit[digit]
                    new_combo_str = "".join(new_combo_list)
                    if new_combo_str not in visited:
                        visited.add(new_combo_str)
                        queue.append(new_combo_str)
            turns_count += 1
        return -1
